<think>
Alright, I need to write a Python function called binary_search that takes an array and a target, and returns the index of the target if it's present, or None if it's not. The array should be sorted, but I guess I don't have to worry about that since it's a prerequisite for binary search.

Okay, binary search works by repeatedly dividing the search interval in half. So I'll start by initializing two pointers, low and high, to the start and end of the array.

Wait, how do I handle the middle index? Oh right, I can calculate it as (low + high) // 2. But I need to be careful because if low + high is too big, it might cause an overflow, but in Python that's not really an issue.

So the steps are: while low is less than or equal to high, compute mid. If the target is at arr[mid], return mid. If the target is less than arr[mid], set high to mid -1. Otherwise, set low to mid +1.

But wait, what if there are duplicate elements? Well, the problem doesn't specify whether to return the first occurrence or any, so I think returning any is fine unless stated otherwise.

What about edge cases? Like when the array is empty, the function should return None. Or when the target is smaller than the first element or larger than the last.

Let me think about an example. If the array is [2,5,8,11,13], looking for 8. Low is 0, high is 4. Mid is 2, which is 8, so return 2.

Another example: searching for 6 in [1,3,5,7]. Low starts at 0, high at 3. Mid is 1 (3). 6 is bigger, so set low to 2. Mid becomes (2+3)//2=2.5, which is 2 in integer division. Arr[2] is 5. 6 is bigger, so set low to 3. Now mid is (3+3)//2=3. Arr[3] is 7. 6 is smaller, set high to 2. Now low (3) > high (2), so loop ends. Return None.

I should also test when the target is at the boundaries, like the first element. Arr is [1,2,3], target 1. Mid is 1, arr[1] is 2. So target is smaller, set high to 0. Mid becomes 0, arr[0] is 1, return 0.

What about when the array has even number of elements? Say [4,5,6,7], target 5. Mid is (0+3)//2=1.5->1. Arr[1] is 5, so return 1.

I think that covers the basic cases. So, implementing this in Python.

Wait, should I handle the case where the array is unsorted? No, because the function assumes it's sorted as per binary search's requirement.

So, the function starts with low=0 and high=len(arr)-1.

Now, in code:

def binary_search(arr, target) -> Optional[int]:
    low = 0
    high = len(arr) - 1
    while low <= high:
        mid = (low + high) // 2
        if arr[mid] == target:
            return mid
        elif arr[mid] > target:
            high = mid - 1
        else:
            low = mid + 1
    return None

I think that's it. This should handle all cases.
</think>

To implement a binary search function in Python that returns the index of the target element if found, or `None` if not found, follow these steps:

1. **Initialize Pointers**: Set `low` to the start of the array (index 0) and `high` to the end of the array (index `len(arr) - 1`).

2. **Loop Until Pointers Cross**: Continue the search while `low` is less than or equal to `high`.

3. **Calculate Middle Index**: Compute the middle index `mid` as the average of `low` and `high`, using integer division.

4. **Compare Target with Middle Element**:
   - If the target is found at `arr[mid]`, return `mid`.
   - If the target is less than `arr[mid]`, adjust the `high` pointer to `mid - 1` to search the left half.
   - If the target is greater than `arr[mid]`, adjust the `low` pointer to `mid + 1` to search the right half.

5. **Return None if Not Found**: If the loop exits without finding the target, return `None`.

This approach efficiently narrows down the search space by half each iteration, resulting in a time complexity of O(log n).

**Code:**

```python
def binary_search(arr, target) -> Optional[int]:
    low = 0
    high = len(arr) - 1
    while low <= high:
        mid = (low + high) // 2
        if arr[mid] == target:
            return mid
        elif arr[mid] > target:
            high = mid - 1
        else:
            low = mid + 1
    return None
```